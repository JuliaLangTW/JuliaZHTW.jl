<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>概論 (Introduction) · Julia 台灣 中文文件</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Julia 台灣 中文文件</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">首頁</a></li><li class="current"><a class="toctext" href>概論 (Introduction)</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>概論 (Introduction)</a></li></ul><a class="edit-page" href="https://github.com/JuliaLangTW/JuliaZHTW.jl/blob/master/docs/src/introduction.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>概論 (Introduction)</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="概論-(Introduction)-1" href="#概論-(Introduction)-1">概論 (Introduction)</a></h1><p>科學計算一般來說需要極高的效能，然而領域專家往往使用較緩慢的動態程式語言進行開發。我們相信選擇動態語言是基於很多應用上的好理由，所以我們也不希望他們消失。幸運的是，現代語言設計與編譯器技術能讓解決大部分效能取捨的問題，提供單一且具足夠生產力的環境讓大家打造原型，並且可以有效率的交付效能吃重的應用程式。Julia 程式語言足以擔綱這個角色：它是一個具有彈性的動態語言，適合科學與數值運算，同時在效能可以與傳統靜態型別語言媲美。</p><p>Julia 的編譯器與 Python 或 R 的直譯器不同，你起初會發現 Julia 的效能是違反直覺的。如果你發現某些東西慢了，在嘗試其他方法之前，我們強烈建議你閱讀 <a href="/JwY2CYGYHYEMQLTABzGggLAMw+BAjZAVmQVkgwAYA2aAUxBEkliA">效能建議 (Performance Tips)</a> 章節。一旦你了解 Julia 的運作方式之後，你可以很簡單地寫出接近 C 語言效能的程式。</p><p>Julia 的特色有選擇性型別宣告 (optional typing)、多重分派 (multiple dispatch,) 跟絕佳的效能，藉由型別推斷 (type inference) 以及 <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">just-in-time (JIT) compilation</a> 達成，語言核心以 <a href="https://en.wikipedia.org/wiki/Low_Level_Virtual_Machine">LLVM</a> 實作。它是一個多典範（multi-paradigm) 語言，結合了命令式 (imperative)、函數式 (functional) 跟物件導向 (object-oriented programming)。Julia 為高階數值運算提供了易用性與表達性語法，就像 R、MATLAB 跟 Python 語言一般，除此之外也可以用於一般程式設計。為了達成這些，Julia 承襲了數學程式語言，也向主流程式語言借鏡了不少，其中包含 <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a>、 <a href="https://en.wikipedia.org/wiki/Perl_(programming_language)">Perl</a>、<a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a>、<a href="https://en.wikipedia.org/wiki/Lua_(programming_language)">Lua</a>、跟 <a href="https://en.wikipedia.org/wiki/Ruby_(programming_language)">Ruby</a>。</p><p>Julia，相較於典型動態語言，最亮眼的部份包含：</p><ul><li>小巧的語言核心；標準程式庫本身即是由 Julia 自身撰寫而成，包含原始操作 (primitive operations)，像是整數算術運算</li><li>擁有豐富型別用以建構及敘述物件，也可以做選擇性型別宣告</li><li>定義函式行為的能力，藉由多重分派，作用於不同的參數型別組合</li><li>針對不同的參數型別組合自動產生有效率、特化的程式碼</li><li>絕佳效能，逼近靜態編譯語言，像 C</li></ul><p>動態語言使用起來有時候常會以為它是「無型別」，但事實上絕對不是這樣的：每個物件，無論是原始型別或是使用者定義的，都有一個型別。在大多數動態語言中都缺乏型別宣告，然而，這意味著我們無法告訴編譯器關於值的型別，也時常無法明確地討論型別(and often cannot explicitly talk about types at all)。另一方面，在靜態語言，我們可以，通常也是必須，標記型別，型別只存在於 compile time 而且在 run-time 不能被操作或是表示。在 Julia 中，型別本身就是在 run-time 的物件，而且可以用來傳達資訊給編譯器。</p><p>一般的程式設計師不需要特別去使用型別或多重分派，他們是 Julia 的共同核心功能：函式被定義在不同參數型別的組合上，而且會被發派給最相符的函式定義上計算。這個模型很適合數學計算，相較於讓第一個參數「擁有」一個運算，例同傳統物件導向的作法，反而是不自然的。運算子就只是有特別符號的函式-你可以定義新的方法到<code>+</code>函式上，讓加法延伸到使用者定義的型別上。現存的程式碼仍然可以無縫地銜接到新的資料型別上。</p><p>一方面得益於 run-time 的型別推斷 (augmented by optional type annotations)，以及起初就聚焦於運算效能，Julia 的計算效率超越其他動態語言，甚至是其他靜態編譯語言。對於一個大型數值問題，速度一直以來都是，也一直會是，也可能永遠是最重要的：這幾十年來，需要處理的資料量已經輕易的趕上了摩爾定律 (Moore’s Law)。</p><p>Julia 的目標是成為前所未有，集易用、強大與效率於一身的語言。除了上述以外，一些Julia的優勢包含:</p><ul><li>免費而且開源 (<a href="https://github.com/JuliaLang/julia/blob/master/LICENSE.md">MIT licensed</a>)</li><li>使用者定義型別與內建型別一樣小巧快速</li><li>不需要為了效能向量化程式碼；去向量化的程式碼就是快</li><li>特別適合平行化與分散式運算</li><li>輕量的「綠色」執行緒 (<a href="https://en.wikipedia.org/wiki/Coroutine">coroutines</a>)</li><li>不突兀而強大的型別系統</li><li>優雅而可擴充的轉型與向上轉型</li><li>支援 <a href="https://en.wikipedia.org/wiki/Unicode">Unicode</a>，包含但不限於 <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a></li><li>直接呼叫 C 函式 (不需要包裝或是使用特殊 APIs)</li><li>強大的shell-like行程管理能力</li><li>Lisp般的macros與其他metaprogramming的能力</li></ul><p><a href="https://docs.julialang.org/en/stable/manual/introduction/#man-introduction-1">文件原文</a></p><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">首頁</span></a></footer></article></body></html>
